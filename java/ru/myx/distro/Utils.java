package ru.myx.distro;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Properties;
import java.util.stream.Stream;

import ru.myx.distro.prepare.ConsoleOutput;

public class Utils {

    public static int clearFolderContents(final ConsoleOutput console, final Path root) throws Exception {

	console.outDebug("Utils.clearFolderContents: ", root);

	console.outProgress("U(");

	int count = 0;

	try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(root)) {
	    console.outProgress('*');
	    for (final Path path : directoryStream) {
		final String name = path.getFileName().toString();
		if (name.length() == 0) {
		    continue;
		}
		if (Files.isDirectory(path)) {
		    count += Utils.clearFolderContents(console, path);
		    Files.delete(path);
		    console.outProgress('<');
		    ++count;
		    continue;
		}
		if (Files.isRegularFile(path)) {
		    Files.delete(path);
		    console.outProgress('-');
		    ++count;
		    continue;
		}
	    }
	}

	console.outProgress(")");

	return count;
    }

    public static boolean save(final ConsoleOutput console, final Path path, final byte[] contents) throws Exception {

	console.outDebug("Utils.save: bytes ", path);

	compare: if (Files.exists(path)) {
	    final BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes.class);
	    if (attributes.isDirectory()) {
		throw new IllegalStateException("Properties file is a directory!");
	    }
	    if (!attributes.isRegularFile()) {
		throw new IllegalStateException("Properties file exists but not a file!");
	    }
	    if (attributes.size() != contents.length) {
		break compare;
	    }
	    final byte[] comparison = Files.readAllBytes(path);
	    if (!Arrays.equals(comparison, contents)) {
		break compare;
	    }
	    console.outProgress('.');
	    return false;
	}
	{
	    final Path tempFile = Files.createTempFile(//
		    path.getParent(), //
		    path.getFileName().toString(), //
		    "", //
		    PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString("rwxrwx---"))//
	    );
	    Files.write(tempFile, //
		    contents, //
		    StandardOpenOption.CREATE, //
		    StandardOpenOption.TRUNCATE_EXISTING, //
		    StandardOpenOption.WRITE//
	    );
	    Files.move(tempFile, path, StandardCopyOption.REPLACE_EXISTING);
	    console.outProgress('I');
	    return true;
	}
    }

    public static boolean save(final ConsoleOutput console, final Path path, final Stream<String> lines)
	    throws Exception {

	console.outDebug("Utils.save: stream ", path);

	final byte[] contents;
	{
	    final ByteArrayOutputStream out = new ByteArrayOutputStream();
	    try (final BufferedWriter writer = new BufferedWriter(
		    new OutputStreamWriter(out, StandardCharsets.UTF_8))) {

		// writer.write("# Generated by ru.myx.distro.prepare");
		// writer.write('\n');

		for (Iterator<String> iterator = lines.iterator(); iterator.hasNext();) {
		    String line = iterator.next();
		    if (line.startsWith("#")) {
			continue;
		    }
		    writer.write(line);
		    writer.write('\n');
		}

	    }
	    contents = out.toByteArray();
	}
	return save(console, path, contents);
    }

    public static boolean save(final ConsoleOutput console, final Path path, final Iterable<String> lines)
	    throws Exception {

	console.outDebug("Utils.save: stream ", path);

	final byte[] contents;
	{
	    final ByteArrayOutputStream out = new ByteArrayOutputStream();
	    try (final BufferedWriter writer = new BufferedWriter(
		    new OutputStreamWriter(out, StandardCharsets.UTF_8))) {

		// writer.write("# Generated by ru.myx.distro.prepare");
		// writer.write('\n');

		for (Iterator<String> iterator = lines.iterator(); iterator.hasNext();) {
		    String line = iterator.next();
		    if (line.startsWith("#")) {
			continue;
		    }
		    writer.write(line);
		    writer.write('\n');
		}

	    }
	    contents = out.toByteArray();
	}
	return save(console, path, contents);
    }

    public static boolean save(final ConsoleOutput console, final Path path, final Properties info,
	    final String comment, final boolean sorted) throws Exception {

	console.outDebug("Utils.save: properties ", path, ", # ", comment);

	final byte[] contents;
	{
	    final ByteArrayOutputStream bos = new ByteArrayOutputStream();
	    info.store(//
		    bos, //
		    null//
	    );
	    final String[] lines = new String(bos.toByteArray(), StandardCharsets.UTF_8).split("\n");

	    if (sorted) {
		Arrays.sort(lines, (o1, o2) -> o1.compareTo(o2));
	    }

	    final ByteArrayOutputStream out = new ByteArrayOutputStream();
	    try (final BufferedWriter writer = new BufferedWriter(
		    new OutputStreamWriter(out, StandardCharsets.UTF_8))) {

		writer.write("# ");
		writer.write(comment);
		writer.write('\n');

		for (String line : lines) {
		    if (line.startsWith("#")) {
			continue;
		    }
		    writer.write(line);
		    writer.write('\n');
		}

	    }
	    contents = out.toByteArray();
	}
	return save(console, path, contents);
    }

    public static int sync(final ConsoleOutput console, final Iterable<Path> sourceRoots, final Path targetRoot)
	    throws Exception {

	console.outDebug("Utils.sync: ", sourceRoots, targetRoot);

	final FolderSyncCommand command = new FolderSyncCommand(//
		FolderSyncOption.IGNORE_HIDDEN, //
		FolderSyncOption.KEEP_DATES //
	);
	command.console = console;
	command.addSourceRoots(sourceRoots);
	command.setTargetRoot(targetRoot);
	command.addExcludeName("CVS");
	command.doSync();
	return command.updates;
    }

    /**
     * <code>
    	try (final Stream<Path> paths = Files.find(root, Integer.MAX_VALUE, new BiPredicate<Path, BasicFileAttributes>(){
    
    		&#64;Override
    		public boolean test(Path t, BasicFileAttributes u) {
    			// TODO Auto-generated method stub
    			return false;
    		}
    
    	})) {
    
    	}
    	</code>
     */
    /**
     * <code>
    	try (final Stream<Path> paths = Files.walk(root)) {
    		paths.forEachOrdered(new Consumer<Path>() {
    
    			&#64;Override
    			public void accept(Path path) {
    				System.err.println("DEL: " + path);
    			}
    		});
    	}
    	</code>
     */

}
