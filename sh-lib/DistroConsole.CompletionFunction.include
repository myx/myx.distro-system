#!/usr/bin/env bash
# ^^^ for syntax checking in the editor only

    # — grab the words we need
    local cur verb roots_list roots suggestion
    cur=${COMP_WORDS[COMP_CWORD]}      # the word under the cursor
    verb=${COMP_WORDS[1]}              # the first arg (your sub‐command)

    # — define all the candidates, then filter only actually‐defined functions
    roots_list="Require Action Source Distro Deploy"
    roots=""
    for r in $roots_list; do
        [ "$(type -t "$r")" = function ] && roots="$roots $r"
    done

    # 1) SLOT 1 (COMP_CWORD==1): offer exactly those roots
    if [ "$COMP_CWORD" -eq 1 ]; then
        COMPREPLY=( $(compgen -W "$roots" -- "$cur") )
        return 0
    fi

    # 2) SLOT ≥2 & special-verb? dispatch into its handler
    case "$verb" in
      Require)
        COMPREPLY=( $(Distro --completion-require) )
        return 0
        ;;
      Action)
        # load ListAllActions on demand
        Require ListAllActions
        local out
        out=$(ListAllActions --completion)
        if [ -z "$cur" ]; then
            COMPREPLY=( $(
              printf '%s\n' "$out" |
              sed 's!/.*!/!' |
              sort -u
            ) )
        else
            COMPREPLY=( $(
              printf '%s\n' "$out" |
              grep "^$cur" |
              sort -u
            ) )
        fi
        return 0
        ;;
      Source)
        COMPREPLY=( $(Distro --completion-source) )
        return 0
        ;;
      Distro)
        COMPREPLY=( $(Distro --completion-distro) )
        return 0
        ;;
      Deploy)
        COMPREPLY=( $(Distro --completion-deploy) )
        return 0
        ;;
    esac

    # 3) FALLBACK for everything else: commands + files, minus the root verbs
    COMPREPLY=()
    for suggestion in $(compgen -c -- "$cur") $(compgen -f -- "$cur"); do
        case " $roots " in
          *" $suggestion "*) continue ;;  # skip if it’s one of your roots
        esac
        COMPREPLY+=("$suggestion")
    done

    return 0
