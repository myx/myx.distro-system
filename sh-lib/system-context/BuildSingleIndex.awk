#!/usr/bin/awk -f
# Usage:
#   printf '%s\n' file1 file2 ... | awk -v source="/path/to/dir" -f make_prj_list_esc_fixed.awk

BEGIN {
	want["Provides"]="PRJ-PRV-"
	want["Requires"]="PRJ-REQ-"
	want["Declares"]="PRJ-DCL-"
	want["Keywords"]="PRJ-KWD-"
	want["Augments"]="PRJ-AUG-"

	self["Provides"]=1
	self["Declares"]=1
	self["Augments"]=1

	name["Provides"]=1
	name["Declares"]=1
	name["Keywords"]=1
}

# read relpaths from stdin
{
	if ($0 == "") next
	prj = $0
	projects[++fc] = prj
	filepath = source "/" prj "/project.inf"

	for (k in want) {
		if(k in self){
			data[prj,k] = (k in name ? prj " " substr(prj, index(prj,"/")+1) " " : prj " " )
		}else
		if(k in name){
			data[prj,k] = substr(prj, index(prj,"/")+1) " "
		}else{
			data[prj,k] = ""
		}
	}

	remainder = ""
	while ((getline raw < filepath) > 0 || remainder != "") {
		line = raw; raw = ""
		sub(/\r$/, "", line)

		# continuation: ends with unescaped backslash
		if (match(line, /(^|[^\\])\\$/)) {
			sub(/\\$/, "", line)
			remainder = remainder line
			continue
		}
		if (remainder != "") {
			line = remainder line
			remainder = ""
		}

		gsub(/[ \t]+/, " ", line)

		# split on first '=' or ':' using regexp match to get position
		if (!match(line, /[=:]/)) continue

		key = substr(line, 1, RSTART - 1)
		value = substr(line, RSTART + 1)

		sub(/^[ ]+/, "", key); sub(/[ ]+$/, "", key)
		sub(/^[ ]+/, "", value); sub(/[ ]+$/, "", value)

		if ( key == "" || value == "" ) continue

		if (key in want) {
			if(index(" " data[prj,key], " " value " ") == 0) data[prj,key] = data[prj,key] value " "
		} else
		if (key == "Name") {
			for (k in name) {
				if(index(" " data[prj,k], " " value " ") == 0) data[prj,k] = data[prj,k] value " "
			}
		}
	}
	close(filepath)
}

END {
	print "# Generated by myx.distro-system, single index"

	# --- load providesMap and populate queue (unique projects appended to right) ---
	for (j = 1; j <= fc; j++) {
		prj = projects[j]
		n = split(data[prj,"Provides"], arr, " ")
		for (i=1;i<=n;i++) {
			pv = arr[i]
			if (pv == "") continue
			provider_count[pv]++
			provider[pv, provider_count[pv]] = prj
		}
	}

	# --- load requiresMap (resolve requireValue -> provider projects); report missing once per requireValue ---
	for (j = 1; j <= fc; j++) {
		prj = projects[j]
		n = split(data[prj,"Requires"] " " prj, arr, " ")
		for (i = 1; i <= n; i++) {
			rv = arr[i]
			if (rv == "") continue
			sub(/:.*/, "", rv)                        # strip suffix after first colon
			if (rv == "") continue
			left[prj] = 1
			if (provider_count[rv] > 0) {
				for (k = 1; k <= provider_count[rv]; k++) {
					t = provider[rv, k]
					requires_count[prj]++
					requires[prj, requires_count[prj]] = t
					if (!(t in left)) left[t] = 0
				}
			} else {
				if (!missing_reported[rv]) {
					out = "no '" rv "' provider, required from '" prj "'"
					print "â›” MISSING:" out > "/dev/stderr"
					missing_reported[out] = 1
				}
			}
		}
	}


	# 4. sequence resolver (adapted from standalone)
	qt = 0
	for (i = fc; i >= 1; i--) queue[++qt] = projects[i]

	# --- main loop: operate on right side as stack top (qt) ---
	while (qt > 0) {
		prj = queue[qt]                       # peek from right (do not pop yet)

		if (prj in flushed) { qt--; continue }    # pop/delete on the right if already flushed

		# per-iteration visitedMap
		delete visited
		visited[prj] = 1

		# seed work list with prj's immediate requires (preserve order)
		work_n = 0
		rc = requires_count[prj] + 0
		for (i = 1; i <= rc; i++) work[++work_n] = requires[prj, i]

		# scan work left-to-right, expanding flushed entries inline, pushing unmet to right
		idx = 1
		unflushed = 0
		while (idx <= work_n) {
			r = work[idx++]
			# treat r as a project if it exists in providesMap (provider_count[r] present)
			if (provider_count[r]) {
				if (r in flushed) { continue }    # flushed -> satisfied, skip
				if (visited[r]) { continue }      # visited -> skip, do not increment unflushed
				unflushed++
				queue[++qt] = r
				visited[r] = 1
			}
		}
		# clear work array slots
		for (k = 1; k <= work_n; k++) delete work[k]

		if (unflushed == 0) {
			for (k in want) {
				prefix = want[k]
				v = data[prj,k]
				sub(/[ ]+$/, "", v)
				gsub(/:/, "\\:", v)
				printf "%s%s=%s\n", prefix, prj, v
			}

			qt--    # remove project from queue (pop from right)
			flushed[prj] = 1

			# unroll requires[prj] into flattened list (replace current project's requires with expanded list)
			new_n = 0; delete seen_new
			for (j=1; j<=requires_count[prj]; j++) { 
				x = requires[prj, j]
				if (x == prj) {
					if (!seen_new[x]) new[++new_n] = x
					continue
				}
				if (requires_count[x]) {
					for (t = 1; t <= requires_count[x]; t++) {
						v = requires[x,t]
						if (!seen_new[v]) new[++new_n] = v
					}
				} else {
					if (!seen_new[x]) new[++new_n] = x
				}
			}
			requires_count[prj] = new_n
			for (j = 1; j <= new_n; j++) requires[prj, j] = new[j]

			out = "PRJ-SEQ-" prj ; SEP = "=" ; delete seen
			for (j = 1; j <= new_n; j++) {
				seq = requires[prj, j] 
				if(seen[seq]++) continue
				out = out SEP seq; SEP = " "
			}
			print out

			for (j = 1; j <= new_n; j++) delete new[j]

			continue
		}

		# if unflushed > 0: do not pop prj; leave it on right (newly pushed items are on right and will be processed next)
	}

	printf "PRJS="
	sep=""
	for (prj in projects) { printf "%s%s", sep, projects[prj]; sep=" " }
	print ""

}
