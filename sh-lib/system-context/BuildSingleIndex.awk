#!/usr/bin/awk -f
# Usage:
#   printf '%s\n' file1 file2 ... | awk -v source="/path/to/dir" -f make_prj_list_esc_fixed.awk

BEGIN {
	want["Provides"]="PRJ-PRV-"
	want["Requires"]="PRJ-REQ-"
	want["Declares"]="PRJ-DCL-"
	want["Keywords"]="PRJ-KWD-"
	want["Augments"]="PRJ-AUG-"

	self["Provides"]=1
	self["Declares"]=1
	self["Augments"]=1

	name["Provides"]=1
	name["Declares"]=1
	name["Keywords"]=1
}

# read relpaths from stdin
{
	rel = $0
	if (rel == "") next
	projects[++fc] = rel
	filepath = source "/" rel "/project.inf"

	for (k in want) {
		if(k in self){
			data[rel,k] = (k in name ? rel " " substr(rel, index(rel,"/")+1) " " : rel " " )
		}else
		if(k in name){
			data[rel,k] = substr(rel, index(rel,"/")+1) " "
		}else{
			data[rel,k] = ""
		}
	}

	remainder = ""
	while ((getline raw < filepath) > 0 || remainder != "") {
		line = raw; raw = ""
		sub(/\r$/, "", line)

		# continuation: ends with unescaped backslash
		if (match(line, /(^|[^\\])\\$/)) {
			sub(/\\$/, "", line)
			remainder = remainder line
			continue
		}
		if (remainder != "") {
			line = remainder line
			remainder = ""
		}

		gsub(/[ \t]+/, " ", line)

		# split on first '=' or ':' using regexp match to get position
		if (!match(line, /[=:]/)) continue

		key = substr(line, 1, RSTART - 1)
		value = substr(line, RSTART + 1)

		sub(/^[ ]+/, "", key); sub(/[ ]+$/, "", key)
		sub(/^[ ]+/, "", value); sub(/[ ]+$/, "", value)

		if ( key == "" || value == "" ) continue

		if (key in want) {
			if(index(" " data[rel,key], " " value " ") == 0) data[rel,key] = data[rel,key] value " "
		} else
		if (key == "Name") {
			for (k in name) {
				if(index(" " data[rel,k], " " value " ") == 0) data[rel,k] = data[rel,k] value " "
			}
		}
	}
	close(filepath)
}

END {
	print "# Generated by myx.distro-system, single index"

	# 3. build maps from collected data
	for (j = 1; j <= fc; j++) {
		rel = projects[j]
		n = split(data[rel,"Provides"], arr, " ")
		for (i=1;i<=n;i++) {
			pv = arr[i]
			if (pv=="") continue
			provider_count[pv]++
			provider[pv,provider_count[pv]] = rel
		}
	}

	for (j = 1; j <= fc; j++) {
		rel = projects[j]
		#requires_count[rel]++
		#requires[rel, requires_count[rel]] = rel
        n = split(data[rel,"Requires"] " " rel, arr, " ")
        for (i = 1; i <= n; i++) {
            rv = arr[i]
            if (rv == "") continue
            sub(/:.*/, "", rv)                        # strip suffix after first colon
            if (rv == "") continue
		    left[rel] = 1
            if (provider_count[rv] > 0) {
                for (k = 1; k <= provider_count[rv]; k++) {
                    t = provider[rv, k]
                    requires_count[rel]++
                    requires[rel, requires_count[rel]] = t
			        if (!(t in left)) left[t] = 0
                }
            } else {
                if (!missing_reported[rv]) {
                    print "â›” MISSING: no provider for " rv > "/dev/stderr"
                    missing_reported[rv] = 1
                }
            }
        }
	}
	

	# 4. sequence resolver (adapted from standalone)
    qt = 0
    for (i = 1; i <= fc; i++) queue[++qt] = projects[i]
	if (qt > 1) {
		half = int(qt/2)
		for (i = 1; i <= half; i++) {
		tmp = queue[i]
		queue[i] = queue[qt - i + 1]
		queue[qt - i + 1] = tmp
		}
	}

    while (qt > 0) {
        cur = queue[qt]                       # peek from right (do not pop yet)

        if (cur in flushed) { qt--; continue }    # pop/delete on the right if already flushed

        # per-iteration visitedMap
        delete visited
        visited[cur] = 1

        # seed work list with cur's immediate requires (preserve order)
        work_n = 0
        rc = requires_count[cur] + 0
        for (i = 1; i <= rc; i++) work[++work_n] = requires[cur, i]

        # scan work left-to-right, expanding flushed entries inline, pushing unmet to right
        idx = 1
        unflushed = 0
        while (idx <= work_n) {
            r = work[idx++]
            # treat r as a project if it exists in providesMap (provider_count[r] present)
            if (provider_count[r]) {
                if (r in flushed) { continue }    # flushed -> satisfied, skip
                if (visited[r]) { continue }      # visited -> skip, do not increment unflushed
                unflushed++
                queue[++qt] = r
                visited[r] = 1
            }
        }
        # clear work array slots
        for (k = 1; k <= work_n; k++) delete work[k]

        if (unflushed == 0) {
			rel = cur
			for (k in want) {
				prefix = want[k]
				v = data[rel,k]
				sub(/[ ]+$/, "", v)
				gsub(/:/, "\\:", v)
				printf "%s%s=%s\n", prefix, rel, v
			}

            qt--    # remove project from queue (pop from right)
            flushed[cur] = 1

            # unroll requires[cur] into flattened list (replace current project's requires with expanded list)
            new_n = 0; delete seen_new
            for (j = 1; j <= requires_count[cur]; j++) {
                x = requires[cur, j]
                if (x == cur) {
                    if (!seen_new[x]) new[++new_n] = x
                    continue
                }
                if (requires_count[x]) {
                    for (t = 1; t <= requires_count[x]; t++) {
                        v = requires[x,t]
                        if (!seen_new[v]) new[++new_n] = v
                    }
                } else {
                    if (!seen_new[x]) new[++new_n] = x
                }
            }
            requires_count[cur] = new_n
			for (j=1; j<=new_n; j++) requires[cur,j]=new[j]

			out = "PRJ-SEQ-" cur ; SEP = "=" ; delete seen
            for (j = new_n; j >= 1; j--) {
				seq = requires[cur, j]; if (seen[seq]++) continue
                out = out SEP seq; SEP = " "
            }
            print out

            for (j = 1; j <= new_n; j++) delete new[j]

            continue
        }

        # if unflushed > 0: do not pop cur; leave it on right (newly pushed items are on right and will be processed next)
    }

	printf "PRJS="
	sep=""
	for (rel in projects) { printf "%s%s", sep, projects[rel]; sep=" " }
	print ""

}
