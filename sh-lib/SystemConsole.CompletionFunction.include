#!/usr/bin/env bash
# ^^^ for syntax checking in the editor only

local cmd sub cur roots_list roots list suggestion filtered

cmd="${COMP_WORDS[0]}"            # the command you invoked
sub="${COMP_WORDS[1]}"            # the 1st argument (if any)
cur="${COMP_WORDS[COMP_CWORD]}"   # what’s under the cursor

#── build the true “root verbs” list
roots_list="Require Action Source Distro Deploy"
roots=""
for v in $roots_list; do
	[ "$(type -t "$v")" = function ] && roots="$roots $v"
done

#── SLOT 1: only if the invoked CMD is NOT itself a root
if [ "$COMP_CWORD" -eq 1 ] && ! printf '%s\n' $roots | grep -qx "$cmd" ; then
	if [ -z "$cur" ] ; then
		# no prefix yet → only your roots
		COMPREPLY=( $(compgen -W "$roots" -- "") )
		# dedupe & sort
		COMPREPLY=( $(printf '%s\n' "${COMPREPLY[@]}" | sort -u) )
		return 0
	fi
fi

#── SLOT 2+: if the first word IS one of your roots, dispatch
case "$cmd" in
	Require)
		list=$(Distro --completion-require)
		COMPREPLY=( $(compgen -W "$list" -- "$cur") )
		return 0
	;;
	Action)
		# 1) Ensure ListAllActions() is loaded
		Require ListAllActions

		# 2) Grab the full “name[/path/…]” list
		local out suggestions
		out=$(ListAllActions --completion)

		# 3) If there’s already a slash in $cur → do full‐path completion
		if [[ "$cur" == */* ]]; then
			suggestions=( $( compgen -W "$out" -- "$cur" ) )
		else
			suggestions=( $( \
				printf '%s\n' "$out" | sed 's!/.*!/!' | sort -u | grep "$cur" \
			) )
			# prevent bash from appending a space after a match
			type compopt &>/dev/null && compopt -o nospace
		fi

		# 6) Return them
		COMPREPLY=( "${suggestions[@]}" )
		return 0
	;;
	Source)
		list=$(Distro --completion-source)
		COMPREPLY=( $(compgen -W "$list" -- "$cur") )
		# only “consume” if we found matches or there's no input yet
		if [ ${#COMPREPLY[@]} -gt 0 ] || [ -z "$cur" ]; then
			return 0
		fi
		# otherwise fall through so default/file-name completion can fire	
	;;
	Distro)
		list=$(Distro --completion-distro)
		COMPREPLY=( $(compgen -W "$list" -- "$cur") )
		# only “consume” if we found matches or there's no input yet
		if [ ${#COMPREPLY[@]} -gt 0 ] || [ -z "$cur" ]; then
			return 0
		fi
		# otherwise fall through so default/file-name completion can fire	
	;;
	Deploy)
		list=$(Distro --completion-deploy)
		COMPREPLY=( $(compgen -W "$list" -- "$cur") )
		# only “consume” if we found matches or there's no input yet
		if [ ${#COMPREPLY[@]} -gt 0 ] || [ -z "$cur" ]; then
			return 0
		fi
		# otherwise fall through so default/file-name completion can fire	
	;;
esac

#    if $cur looks like a path, bail out (return 1)
#    so Bash does its native filename completion perfectly.
case "$cur" in
	*/*) return 1 ;;    # hand off to the built-in file completer
esac

# 2) gather everything bash‐ and file‐wise
COMPREPLY=( $(compgen -c -- "$cur") $(compgen -f -- "$cur") )
# 3) filter & append slashes in one loop
filtered=()
for cand in "${COMPREPLY[@]}"; do
	# drop any “root” words
	case " $roots " in
	*" $cand "*) continue ;;
	esac
	filtered+=( "$cand" )
done

# 3) if exactly one match, tack on a trailing space
if [ "${#filtered[@]}" -eq 1 ]; then
  return 1
fi

COMPREPLY=( "${filtered[@]}" )
return 0
