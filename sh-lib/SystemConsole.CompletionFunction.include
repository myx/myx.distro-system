#!/usr/bin/env bash
# ^^^ for syntax checking in the editor only

set -x

local cmd sub cur roots_list roots list suggestion filtered

cmd="${COMP_WORDS[0]}"            # the command you invoked
sub="${COMP_WORDS[1]}"            # the 1st argument (if any)
cur="${COMP_WORDS[COMP_CWORD]}"   # what’s under the cursor

#── build the true “root verbs” list
roots_list="Require Action Source Distro Deploy"
roots=""
for v in $roots_list; do
	[ "$(type -t "$v")" = function ] && roots="$roots $v"
done

#── SLOT 1: only if the invoked CMD is NOT itself a root
if [ "$COMP_CWORD" -eq 1 ] \
	&& ! printf '%s\n' $roots | grep -qx "$cmd"
then
	if [ -z "$cur" ]; then
		# no prefix yet → only your roots
		COMPREPLY=( $(compgen -W "$roots" -- "") )
	else
		# user typed some prefix → roots + system commands
		COMPREPLY=( \
			$(compgen -W "$roots" -- "$cur") \
			$(compgen -c   -- "$cur") \
		)
	fi
	# dedupe & sort
	COMPREPLY=( $(printf '%s\n' "${COMPREPLY[@]}" | sort -u) )
	return 0
fi

#── SLOT 2+: if the first word IS one of your roots, dispatch
case "$cmd" in
	Require)
	list=$(Distro --completion-require)
	COMPREPLY=( $(compgen -W "$list" -- "$cur") )
	return 0
	;;
	Action)
	# 1) Ensure ListAllActions() is loaded
	Require ListAllActions

	# 2) Grab the full “name[/path/…]” list
	local out suggestions
	out=$(ListAllActions --completion)

	# 3) If there’s already a slash in $cur → do full‐path completion
	if [[ "$cur" == */* ]]; then
		suggestions=( $( compgen -W "$out" -- "$cur" ) )
	else
		suggestions=( $( \
			printf '%s\n' "$out" | sed 's!/.*!/!' | sort -u | grep "$cur" \
		) )
		# prevent bash from appending a space after a match
		type compopt &>/dev/null && compopt -o nospace
	fi

	# 6) Return them
	COMPREPLY=( "${suggestions[@]}" )
	return 0
	;;
	Source)
	list=$(Distro --completion-source)
	COMPREPLY=( $(compgen -W "$list" -- "$cur") )
	return 0
	;;
	Distro)
	list=$(Distro --completion-distro)
	COMPREPLY=( $(compgen -W "$list" -- "$cur") )
	return 0
	;;
	Deploy)
	list=$(Distro --completion-deploy)
	COMPREPLY=( $(compgen -W "$list" -- "$cur") )
	return 0
	;;
esac

#── FALLBACK for any deeper slot or non-root CMD:
#    regular commands + files, but strip out your roots
# 1) try filename‐mode if supported
if type compopt >/dev/null 2>&1; then
	compopt -o filenames 2>/dev/null || :
fi

# 2) gather everything bash‐ and file‐wise
COMPREPLY=( $(compgen -c -- "$cur") $(compgen -f -- "$cur") )
echo ">>>> $COMPREPLY" >&2
# 3) filter & append slashes in one loop
filtered=()
for cand in "${COMPREPLY[@]}"; do
	# drop any “root” words
	case " $roots " in
	*" $cand "*) continue ;;
	esac
	# if it's a real dir, make sure it ends with “/”
	if [ -d "$cand" ]; then
	case "$cand" in
		*/) filtered+=( "$cand" ) ;;
		*)  filtered+=( "$cand/" ) ;;
	esac
	else
	filtered+=( "$cand" )
	fi
done

COMPREPLY=( "${filtered[@]}" )
return 0
	
#── FALLBACK for any deeper slot or non-root CMD:
#    regular commands + files, but strip out your roots.
#    Try compopt; always append “/” on actual dirs.

# 1) Enable filename mode if possible (Bash 4+):
if type compopt >/dev/null 2>&1; then
  compopt -o filenames 2>/dev/null || :
fi

# 2) Pull in all commands + file paths
COMPREPLY=( $(compgen -c -- "$cur") $(compgen -f -- "$cur") )

# 3) Post-process: every entry that names a real directory gets a trailing “/”
for i in "${!COMPREPLY[@]}"; do
  cand=${COMPREPLY[i]}
  # skip empty or commands
  [ -d "$cand" ] || continue
  case "$cand" in
    */) ;;               # already has slash
    *) COMPREPLY[i]="$cand/";;
  esac
done

# 4) Strip out any “roots” you don’t want re-listed
filtered=()
for suggestion in "${COMPREPLY[@]}"; do
  case " $roots " in
    *" $suggestion "*) continue;;
  esac
  filtered+=( "$suggestion" )
done
COMPREPLY=( "${filtered[@]}" )
return 0
