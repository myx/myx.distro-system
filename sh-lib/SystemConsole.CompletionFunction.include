#!/usr/bin/env bash
# ^^^ for syntax checking in the editor only

set -e

local cmd sub cur roots_list roots list suggestion filtered

cmd="${COMP_WORDS[0]}"            # the command you invoked
sub="${COMP_WORDS[1]}"            # the 1st argument (if any)
cur="${COMP_WORDS[COMP_CWORD]}"   # what‚Äôs under the cursor

#‚îÄ‚îÄ build the true ‚Äúroot verbs‚Äù list
roots_list="Require Action Source Distro Deploy"
roots=""
for v in $roots_list; do
	[ "$(type -t "$v")" = function ] && roots="$roots $v"
done

#‚îÄ‚îÄ SLOT 1: only if the invoked CMD is NOT itself a root
if [ -z "$cmd" ] || [ "$COMP_CWORD" -eq 1 ] && ! printf '%s\n' $roots | grep -qx "$cmd" ; then
	case "$cmd" in
		*.fn.sh)
		;;
		*)
			# no prefix yet ‚Üí only your roots
			COMPREPLY=( $(compgen -W "$roots" -- "") )
			# dedupe & sort
			COMPREPLY=( $(printf '%s\n' "${COMPREPLY[@]}" | sort -u) )
			return 0
		;;
	esac
fi

#‚îÄ‚îÄ SLOT 2+: if the first word IS one of your roots, dispatch
case "$cmd" in
	Require)
		list=$(Distro --completion-require)
		if [ "$COMP_CWORD" -eq 1 ]; then
			COMPREPLY=( $(compgen -W "$list" -- "$cur") )
			return 0
		fi
		COMPREPLY=()    # eat the TAB, no suggestions
		set +e ; return 1
	;;
	Action)
		# 1) Ensure ListAllActions() is loaded
		Require ListAllActions

		if [ -z "$cur" ]; then
			COMPREPLY=( $(
				ListAllActions --completion \
				| sed 's!/.*!/!' \
				| sort -u
			) )
			return 0 # don't fall back to filename completion
		fi

		COMPREPLY=()

		# 3) If there‚Äôs already a slash in $cur ‚Üí do full‚Äêpath completion
		if [[ "$cur" == */* ]]; then

			# grep prefix matching
			while IFS= read -r line; do
				[[ $line != "$cur"* ]] || COMPREPLY+=("$line")
			done < <( ListAllActions --completion )

			# try grep more
			if [ "${#COMPREPLY[@]}" -eq 0 ] ; then
				local line
				local curPrefix="${cur%/*}/"
				local curSearch="${cur##*/}"
				while IFS= read -r line; do
				if [[ $line = "$curPrefix"* ]] && [[ ${line#$curPrefix} == *"$curSearch"* ]]; then
					COMPREPLY+=("$line")
				fi
				done < <( ListAllActions --completion )
			fi
		else
			# grep all matching
			while IFS= read -r line; do
				[[ $line != *"$cur"* ]] || COMPREPLY+=("$line")
			done < <( ListAllActions --completion )
		fi

		case "${#COMPREPLY[@]}" in
			# nothing matches
			0) return 0 ;;
			# one match - add space force select
			1) COMPREPLY[0]="${COMPREPLY[0]} " ; return 0 ;;
		esac

		for idx in "${!COMPREPLY[@]}"; do
			if [[ ${COMPREPLY[$idx]} != "$cur"* ]]; then
				# add search token to completion, so it stays typed
				COMPREPLY+=(" üîÄ[ Filter by: \"$cur\" ]:")
				return 0
			fi
		done

		return 0

	;;
	Distro)
		while IFS= read -r line; do
			COMPREPLY+=("$line")
		done < <( Distro --completion-helper-system \
			"$COMP_LINE" "system" \
			'^\(Distro\|Source\|Deploy\|Remote\|Build\|Clean\|List\).*.fn.sh$' \
		) && return 0
		# otherwise fall through so default/file-name completion can fire	
	;;
	Source)
		if COMPREPLY=( $( Distro --completion-helper-system \
			"$COMP_LINE" "source" \
			'^\(DistroSource\|Source\|ListDistro\|ListAll\|Build\|Clean\|ListSource\).*.fn.sh$' \
		) ) ; then
			return 0
		fi
		# otherwise fall through so default/file-name completion can fire	
    ;;
	Deploy)
		if COMPREPLY=( $( Distro --completion-helper-system \
			"$COMP_LINE" "deploy" \
			'^\(DistroDeploy\|Deploy\|ListDistro\|ListAll\|CleanAll\).*.fn.sh$' \
		) ) ; then
			return 0
		fi
		# otherwise fall through so default/file-name completion can fire	
	;;
	*.fn.sh)
		if COMPREPLY=( $( Distro --completion-helper-system \
			"$COMP_LINE" "$cmd" \
		) ) ; then
			return 0
		fi
		# otherwise fall through so default/file-name completion can fire	
	;;
esac

set +e

COMPREPLY=( $(compgen -c -- "$cur") $(compgen -f -- "$cur") )
return 0
