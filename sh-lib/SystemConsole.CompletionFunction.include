#!/usr/bin/env bash
# ^^^ for syntax checking in the editor only

local cmd sub cur roots_list roots list suggestion filtered

cmd="${COMP_WORDS[0]}"            # the command you invoked
sub="${COMP_WORDS[1]}"            # the 1st argument (if any)
cur="${COMP_WORDS[COMP_CWORD]}"   # what’s under the cursor

#── build the true “root verbs” list
roots_list="Require Action Source Distro Deploy"
roots=""
for v in $roots_list; do
	[ "$(type -t "$v")" = function ] && roots="$roots $v"
done

#── SLOT 1: only if the invoked CMD is NOT itself a root
if [ -z "$cmd" ] || [ "$COMP_CWORD" -eq 1 ] && ! printf '%s\n' $roots | grep -qx "$cmd" ; then
	# no prefix yet → only your roots
	COMPREPLY=( $(compgen -W "$roots" -- "") )
	# dedupe & sort
	COMPREPLY=( $(printf '%s\n' "${COMPREPLY[@]}" | sort -u) )
	return 0
fi

#── SLOT 2+: if the first word IS one of your roots, dispatch
case "$cmd" in
	Require)
		list=$(Distro --completion-require)
		if [ "$COMP_CWORD" -eq 1 ]; then
			COMPREPLY=( $(compgen -W "$list" -- "$cur") )
			return 0
		fi
		COMPREPLY=()    # eat the TAB, no suggestions
		return 1
	;;
	Action)
		# 1) Ensure ListAllActions() is loaded
		Require ListAllActions

		# 2) Grab the full “name[/path/…]” list
		local out suggestions
		out=$(ListAllActions --completion)

		# 3) If there’s already a slash in $cur → do full‐path completion
		if [[ "$cur" == */* ]]; then
			suggestions=( $( compgen -W "$out" -- "$cur" ) )
		else
			suggestions=( $( \
				printf '%s\n' "$out" | sed 's!/.*!/!' | sort -u | grep "$cur" \
			) )
			# prevent bash from appending a space after a match
			type compopt &>/dev/null && compopt -o nospace
		fi

		# 6) Return them
		COMPREPLY=( "${suggestions[@]}" )
		return 0
	;;
	Source)
		local cur list sub

		# word under cursor
		cur="${COMP_WORDS[COMP_CWORD]}"
		# grab the vertical list
		list=$(Distro --completion-source)

		# 1) 2nd token in flight? offer sub-commands
		if [ "$COMP_CWORD" -eq 1 ]; then
			COMPREPLY=( $(compgen -W "$list" -- "$cur") )
			return 0
		fi

		# 2) 3rd token TAB with empty cur? exact-match → help
		if [ "$COMP_CWORD" -eq 2 ] && [ -z "$cur" ]; then
			# grep -F = fixed string; -x = whole line; -q = quiet
			if printf '%s\n' "$list" | grep -Fxq -- "${COMP_WORDS[1]}"; then
				printf "\r\n\r\n%s\r\n\r\n >>> \$ %s" \
				"$( ( Source "${COMP_WORDS[1]}" --help ) 2>&1 )" \
				"${COMP_WORDS[*]}"
				>&2
			fi
			COMPREPLY=()    # eat the TAB, no suggestions
			return 1
		fi
		# 3) otherwise fall through to your manual default+filenames
    ;;
	Distro)
		local cur list sub

		# word under cursor
		cur="${COMP_WORDS[COMP_CWORD]}"
		# grab the vertical list
		list=$(Distro --completion-distro)

		# 1) 2nd token in flight? offer sub-commands
		if [ "$COMP_CWORD" -eq 1 ]; then
			COMPREPLY=( $(compgen -W "$list" -- "$cur") )
			return 0
		fi

		# 2) 3rd token TAB with empty cur? exact-match → help
		if [ "$COMP_CWORD" -eq 2 ] && [ -z "$cur" ]; then
			# grep -F = fixed string; -x = whole line; -q = quiet
			if printf '%s\n' "$list" | grep -Fxq -- "${COMP_WORDS[1]}"; then
				printf "\r\n\r\n%s\r\n\r\n >>> \$ %s" \
				"$( ( Distro --completion-ignore "${COMP_WORDS[1]}" --help ) 2>&1 )" \
				"${COMP_WORDS[*]}"
				>&2
			fi
			COMPREPLY=()    # eat the TAB, no suggestions
			return 1
		fi
		# otherwise fall through so default/file-name completion can fire	
	;;
	Deploy)
		local cur list sub

		# word under cursor
		cur="${COMP_WORDS[COMP_CWORD]}"
		# grab the vertical list
		list=$(Distro --completion-deploy)

		# 1) 2nd token in flight? offer sub-commands
		if [ "$COMP_CWORD" -eq 1 ]; then
			COMPREPLY=( $(compgen -W "$list" -- "$cur") )
			return 0
		fi

		# 2) 3rd token TAB with empty cur? exact-match → help
		if [ "$COMP_CWORD" -eq 2 ] && [ -z "$cur" ]; then
			# grep -F = fixed string; -x = whole line; -q = quiet
			if printf '%s\n' "$list" | grep -Fxq -- "${COMP_WORDS[1]}"; then
				printf "\r\n\r\n%s\r\n\r\n >>> \$ %s" \
				"$( ( Deploy "${COMP_WORDS[1]}" --help ) 2>&1 )" \
				"${COMP_WORDS[*]}"
				>&2
			fi
			COMPREPLY=()    # eat the TAB, no suggestions
			return 1
		fi
		# otherwise fall through so default/file-name completion can fire	
	;;
esac


COMPREPLY=( $(compgen -c -- "$cur") $(compgen -f -- "$cur") )
return 0


#    if $cur looks like a path, bail out (return 1)
#    so Bash does its native filename completion perfectly.
case "$cur" in
	*/*) return 1 ;;    # hand off to the built-in file completer
esac

# 2) gather everything bash‐ and file‐wise
COMPREPLY=( $(compgen -c -- "$cur") $(compgen -f -- "$cur") )
# 3) filter & append slashes in one loop
filtered=()
for cand in "${COMPREPLY[@]}"; do
	# drop any “root” words
	case " $roots " in
	*" $cand "*) continue ;;
	esac
	filtered+=( "$cand" )
done

# 3) if exactly one match, tack on a trailing space
if [ "${#filtered[@]}" -eq 1 ]; then
  return 1
fi

COMPREPLY=( "${filtered[@]}" )
return 0
